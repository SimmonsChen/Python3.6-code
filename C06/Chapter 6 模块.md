### Chapter 6 模块

模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。

```python
import sys
 
print('命令行参数如下:')
for i in sys.argv:
   print(i)
>>> 
命令行参数如下:
using_sys.py
参数1
参数2
print('\n\nPython 路径为：', sys.path, '\n')
>>> 
Python 路径为：...
```

#### 1. import 语句

想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：

```python
import module1[, module2[,... moduleN]
```

当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。

#### 2. from … import 语句

Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：

```python
from modname import name1[, name2[, ... nameN]]
from fibo import fib, fib2 # 声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。
```

#### 3. from… import * 语句

把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明，简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。

```
from modname import *
```

#### 4. 深入模块

模块除了方法定义，还可以包括可执行的代码。每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。

模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。

模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。

#### 5. __name _ 属性

一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。

**说明：** 每个模块都有一个__name__属性，当其值是'__main__'时，表明该模块自身在运行，否则是被引入。

说明：**__name__** 与 **__main__** 底下是双下划线， **_ _** 是这样去掉中间的那个空格

```python
if __name__ == '__main__':
   print('程序自身在运行')
else:
   print('我来自另一模块')
```

#### 6. dir() 函数

内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回

```python
>>> import fibo, sys
>>> dir(fibo)
['__name__', 'fib', 'fib2']
```

#### 7. 标准模块

Python 本身带着一些标准的模块库，在 Python 库参考文档中将会介绍到（就是后面的"库参考文档"）。

有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。

#### 8. 包

包是一种管理 Python 模块命名空间的形式，采用"点模块名称"。

比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。

目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。

最简单的情况，放一个空的 :file:__init__.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） __all__变量赋值。用户可以每次只导入一个包里面的特定模块，比如:

```python
import sound.effects.echo
```

当使用 **from package import item** 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。

import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 **:exc:ImportError** 异常。反之，如果使用形如 **import item.subitem.subsubitem** 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。

#### 9. 从一个包中导入*

导入语句遵循如下规则：**如果包定义文件 init.py 存在一个叫做 all 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。**

```python
__all__ = ["echo", "surround", "reverse"]
```

无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是"__main__"，一个Python应用程序的主模块，应当总是使用绝对路径引用。